---
title: "An Interview Study Guide For Overachievers"
date: 2018-04-20
categories:
  - blog
tags:
  - JavaScript
  - Career
  - WebApp
  - Guide
keywords:
  - career transition
  - learn programming
  - coding bootcamps
  - interview prep
  - personal brand
  - learn to code
thumbnailImagePosition: left
thumbnailImage: /post/images/long-term-planning.png
coverImage: /post/images/long-term-planning.png
---

Nothing strikes more anxiety and self-doubt than the dreaded job interview. The thought of participating in an activity designed for the sole purpose of evaluating your worth and the potential for rejection is enough to discourage many people from applying to jobs for which they lack all of the qualifications requested by the job posting. While qualification is important to accomplish the advertised job, it is not everything an employer looks for in a person they want to hire to be a part of the team, to grow with the company and help the company grow. The goal of this article is to provide a guide based on my personal experience for how to prepare for getting offers from jobs for which you don't have all the qualifications.

<!--more-->
<!--toc-->

# Close The Expectation Gap

So you want to be a software engineer? What kind of software do you want to engineer? Building applications and consumer software products? Building big data crunching applications for marketers to design more personalized campaigns? Creating open source tools for programmers to be productive and automate away painful and repetitive tasks? Making enterprise applications for companies and government agencies using a repository of templates? Building new products for startups using the latest and greatest stack? Maintaining legacy systems and refactoring them to mitigate obsolescence?

If you don't know what these mean and what kind of special skills you need to be qualified for these roles, then you have an expectation gap.

Expectation is a strong belief that something will happen. Not doing research to substantiate your belief with facts creates an expectation gap. Expectation gap is the difference between reality and fantasy. It leads people to pursue unrealistic goals instead of working on high-value-added goals.

I want to be a professional software engineer so that means understanding:
1. What it's like to live as a software engineer.
2. What knowledge and skills are expected of a software engineers.
3. What are the different career paths and specializations for software engineers.

The following resources helped me close my expectation gap and establish good goals to work towards:

* Kamran Ahmed's [Developer Roadmap](https://github.com/kamranahmedse/developer-roadmap) - infographics on what type of jobs you can do in frontend, backend, devOps and what tools are being used.
* Story of how someone [landed jobs with Microsoft, Amazon, and Twitter without an Ivy League degree](https://medium.freecodecamp.org/how-i-landed-offers-from-microsoft-amazon-and-twitter-without-an-ivy-league-degree-d62cfe286eb8)
* Story of how someone [learned to stop worrying and love the job hunt](https://blog.stephanbehnke.com/how-i-learned-to-stop-worrying-and-love-the-job-hunt-in-toronto/)
* Story of how someone [landing job offers with LinkedIn, Salesforce, Google, Facebook, and Airbnb]
(https://medium.com/@XiaohanZeng/i-interviewed-at-five-top-companies-in-silicon-valley-in-five-days-and-luckily-got-five-job-offers-25178cf74e0f)
* A series of [vlogs on YouTube](https://www.youtube.com/watch?v=ZgdS0EUmn70) by an ex-Facebooker on how the interview process at Facebook or most high tech companies works and how to prepare for each interview.
* [Soft Skills: The Software Developer's Life Manual](https://www.manning.com/books/soft-skills) by John Z. Sonmez - a unique guide offering techniques and practices for a more satisfying life as a professional software developer, with tips such as how to hack the interview, make your resumes less boring, marketing yourself by writing a blog, and finding gaps in your knowledge and closing those gaps.
* [Skill Up: A Software Developer's Guide to Life and Career](https://www.amazon.com/Skill-Up-Software-Developers-Career/dp/1787287033/ref=sr_1_1?s=books&ie=UTF8&qid=1524269233&sr=1-1&keywords=Skill+up) by Jordan Hudgens

# Close The Skills Gap
There's no shortcut. When you don't meet the basic requirements for the job, you won't get the job. In a market economy, money is exchanged for value created. If you lacked the basic requirements to meet the bare minimum expectations for the job, employers would not be willing to exchange money for your service.

You need to close the skills gap as much as possible for the profession that you are in or want to enter. Not meeting all the requirements for the job is not a deal breaker. When you are assessed as a highly talented employer and a great addition to the team who will be of tremendous value to the company once you are up-to-speed, employers are willing to *make an investment* in you. This means, they will pay you a salary for the first few weeks or months to learn what you need on the job so you can perform at the highest level. How much they are willing or able to pay you to close your skills gap depends on many variables such as the employer's budget, other qualified candidates, and how quickly they need someone to fill a position. Getting an internship, formal education, entering a training program, or self-study are all methods for closing the skills gap.

The distinction between paying for a service now and making an investment is important. A good analogy is startup funding. Most of us are a fan of Shark Tank or know what Shark Tank is. When you are a startup founder pitching to investors, you are promising a huge payoff for investors in exchange for money upfront to get their product to market. But an investor is not going to hand out money based on a promise. They want to see your **track record**. They want an **action plan** (the business plan) for how you will to execute the necessary steps to turn the idea to a product that will sell. You get extra credit if you already have started working on the product **on your own**.

These are the principles that guided my preparation for closing the skills gap. I took the following actions to prepare myself for a career as a software engineer:

## 1. Identify Skills Gap

I reviewed job postings and researched trends to help me identify what I need to learn and work on. I read [Medium](https://medium.com/) articles and use [Stackshare](https://stackshare.io/) to explore the current trends in programming, libraries, and tools. I check in with my college friends who got jobs at companies and startups at Silicon Valley what they use at their jobs and what I need to work on in terms of building professional software engineering skills and experience. One friend gave me the advise that the ability to implement automated tests is a big thing employers look for because delivering code with no bugs is an integral part of a software engineering.

## 2. Develop a strong foundation in Computer Science

Having a strong foundation in computer science basics opens doors to opportunities like Facebook and Google who administer white board interviews to gauge your abilities in algorithms and data structure and fundamental problem solving skills.

I studied Electrical and Computer Engineering in college with an emphasis on software engineering. I've completed courses in many  computer science fundamentals: principles of computing; principles of programming; data structure and algorithm; cryptography, computer security, and web security; mathematical proofs; web development, distributed systems, and machine learning. Yet, I understand the importance of continuing to review and practice these fundamental concepts and their applications. There are also things I did not learn, such as functional programming, which I studied on my own through:

* Completing [Scala courses from Coursera](https://github.com/xiaoyunyang/coursera-scala-specialization). The first course in the series is provided by Martin Ordersky, the creator of Scala.
* Studying from the [Functional Programming in Scala](https://www.amazon.com/Functional-Programming-Scala-Paul-Chiusano/dp/1617290653), which I highly recommend because of its depth, clarity, and exercise problems on using Scala to guide readers to develop an understanding and appreciation for functional programming as a framework for problem solving.
* Reading articles published on Medium and watching [talks on YouTube](https://www.youtube.com/watch?v=E8I19uA-wGY) about functional programming.
* Writing [articles about functional programming](/post/how-functional-programming-promotes-developer-productivity/). Personally, I find writing about a topic you are learning extremely helpful in helping you retain and master the new information.

Don't think because you are not interviewing for a Haskell job, you don't need to learn functional programming. Functional programming is a powerful problem solving framework. A friend of mine was asked at a JavaScript interview what a pure function is.  As software is becoming increasingly complex, functional programming concepts and techniques have been [integrated into the mainstream industry practices](https://medium.com/javascript-scene/can-you-avoid-functional-programming-as-a-policy-7bd0570bcfb2).

## 3. Develop Software Design Knowledge

Developing skills in software architecture and design means being effective at putting that fundamental knowledge into practice. I want to work as a web developer so I've been educating myself about design patterns in web development such as REST API, server rendering, client rendering, streaming, socket IO using the incredible amount of learning resources on the web.

If you don't know what you need to know, get a textbook to learn web framework and web application design principles.  I bought several books from [Manning](https://www.manning.com/), which publishes a ton of programming books from people working in the field to provide the most up-to-date information and guides. The best books are those that best balances theory with practical knowledge and walks you through the process of actually building a website:

* [Express in Action](https://www.manning.com/books/express-in-action) by Evan Hahn
* [Isomorphic Web Applications](https://www.manning.com/books/isomorphic-web-applications) by Elyse Kolker Gordon
* [Play for Scala](https://www.manning.com/books/play-for-scala) by Peter Hilton, Erik Bakker, and Francisco Canedo
* [Reactive Web Application](https://www.manning.com/books/reactive-web-applications) by Manuel Bernhardt
* [Functional Reactive Programming](https://www.manning.com/books/functional-reactive-programming) by Stephen Blackheath and Anthony Jones

## 4. Learn To Work With The Latest Tools

When you learn the latest tools, you increase your opportunity of getting a job in the future. Newer tools are created to address shortcomings of older tools and are thus designed to supersede the older tools, making them obsolete in the future. Making older tools your learning objective also puts you at a disadvantage of acquiring an obsolete skills or soon-to-be obsolete skill where competition is more fierce for fewer and fewer jobs. Further,
Getting experience with a new tool puts you at a more even playing field with the software engineers with more years of experience than you because you are all learning the new tool at around the same time. Lastly, new tools are generally easier to work with than old tools because they are designed to be more powerful and user (programmer) friendly than the older tools.

The best way to learn a new tool is to start with the official documentation. Facebook maintains the gold standard for documentation for React. It includes quick setup, examples, tutorials, gotchas, etc. React also has a vibrant community contributing companion tools like React Router and Redux, tutorials, sample projects, FAQs on Stackoverflow, and issue support on Github.

**Programming language**

A programming language is a tool also. It provides an interface for programmers to solve problems. It confuses me why anyone would get religious about a programming language and will want to use it for everything. While many languages are designed to be a general purpose language or for a specific purpose (e.g., JavaScript was made to only run in the browser initially) but they have evolved to fit specific niches and are all tools to add to a developer's toolbox. there's [a time and a place for using each programming language](https://tomassetti.me/best-programming-languages/). For instance:

* *JavaScript* - Designed to only run in the browser. Now has evolved to build entire websites (thanks to Node.js), cross-platform mobile apps (React Native) and OS-agnostic desktop apps (Electron).
* *Python* - Designed to be a general purpose scripting language. Used as a scripting language for processing data and automating tests and processes. Python tried to break into application space with Django but it can't really compete with the versatility of JavaScript or the simplicity of Ruby.
* *Ruby* - Designed to be a general purpose programming language aimed to maximize developer productivity. Ruby on Rails is a web app framework that you can use to very quickly build a web app for which performance is not a requirement. Ruby does not scale well.
* *Java* - Designed to be a general purpose programming language for building applications that can be run on any device that has the Java Virtual Machine installed. Back in the day, it was used by many enterprise systems, especially banking. It was once the language to build Android applications but that was replaced by Kotlin. With tools like React Native, I see little incentive to use Kotlin or Swift to write applications that can only run on one type of device.
* *Go* - Designed to build concurrent applications. Being used to build concurrent applications. I've talked to a few startups who use Go to build their web app's backend that requires speed and high performance.
* *C++* - Designed to be a system programming language. This means writing applications for embedded systems (microprocessors, game consoles) where there are not that much memory to be elegant but inefficient. System programming are defined by their main operating loops and low level logic (e.g., final state machines).

Since the JavaScript is what I decided to use for building my web app and mobile app projects, I've a collection of JavaScript books that I always have handy for reference when I'm stuck on a problem or studying something in-depth:

* [JavaScript: The Good Parts](https://www.amazon.com/JavaScript-Good-Parts-Douglas-Crockford/dp/0596517742/ref=sr_1_1?s=books&ie=UTF8&qid=1524273920&sr=1-1&keywords=javascript+the+good+parts) by Douglas Crockford - covers Grammar, Object, functions, inheritance, arrays, regular expressions, methods, good parts and bad parts about JavaScript. Note, this book was published in 2008 before ES6 came out.
* [Learning JavaScript Design Patterns](https://www.amazon.com/Learning-JavaScript-Design-Patterns-Developers/dp/1449331815/ref=sr_1_3?s=books&ie=UTF8&qid=1524273780&sr=1-3&keywords=javascript+design+patterns) by Addy Osmani - Addy Osmani works at Google and wrote a few books. He's also a progressive web app evangelist.
* [Programming JavaScript Applications](https://www.amazon.com/Programming-JavaScript-Applications-Architecture-Libraries/dp/1491950293) by Eric Elliot - Eric Elliot publishes a lot of JavaScript articles on Medium about JavaScript. His writing is pretty opinionated and sometimes preachy but I can't help agreeing with most of what he says.


## 5. Develop Your Practical Knowledge

The best way to develop your practical knowledge as a web developer is to be a web developer. When you are building real apps, you encounter questions like how do I create a web page that looks good on any device, how do I design my databases to get the least latency when fetching and writing to the database, how do I improve reusability of my code and make it easier to maintain and test, or how do I keep my code organized using a good folder structure.

For practical knowledge, my strategy is to start my own projects building websites. I started with vanilla HTML with a CSS framework like MaterializeCSS, then added a bit more complexity by turning it into a single page application with React and D3, followed by adding a backend with a JSON API to serve data to the single page application, and finally graduating to isomorphic web app with the capability of both server render and client render.

Along the way, I gained an understanding and an appreciation for the process of developing a web app, learned to be resourceful and efficient with doing research, leveraging Github, StackOverflow, documentations, other people's blogs and open source sample projects. I find it much easier to google for answers and do research when you know the key words.

**"Best Practice" books** exists to help you develop your practical problem solving skills by introducing you to the industry lexicon and mental framework for being a professional software engineer or designer.

* [Don't Make Me Think](https://www.amazon.com/Dont-Make-Think-Revisited-Usability/dp/0321965515/ref=pd_lpo_sbs_14_t_0?_encoding=UTF8&psc=1&refRID=R8VCWJMSFTBBBMVD5J94) by Steve Krug - Designing web apps for usability
* [Information Architecture](https://www.amazon.com/Information-Architecture-Beyond-Louis-Rosenfeld/dp/1491911689/ref=sr_1_1?ie=UTF8&qid=1524274182&sr=8-1&keywords=information+architecture) by Louis Rosenfeld and Peter Morville, and Jorge Arango  - commonly known as "the Polar Bear book"
* [The Responsive Web](https://www.manning.com/books/the-responsive-web) by Matthew Carver

Unlike the programming books, which I always read on my laptop so I can try out the examples as I read, I read these best practice books on my smart phone while I'm riding the subway or on the elliptical at the gym. The best practice books are there to make you think, and inspire you to try something different.

Many **Github repositories** also exists dedicated to best practices, including

* Google's [Style Guide for HTML and CSS](https://google.github.io/styleguide/htmlcssguide.html#ID_and_Class_Name_Delimiters)
* Airbnb's [JavaScript Style Guide](https://github.com/airbnb/javascript)
* [Wearhive's List Of Best Practices for JavaScript Projects](https://github.com/wearehive/project-guidelines#readme)
* Joe Morgan's [React Best Practices](https://github.com/jsmapr1/react-best-practices)
* [TLDR Addy Osmani Design Patterns](https://github.com/karlpatrickespiritu/TLDR-Learning-JS-Design-Patterns-by-Addy-Osmani)
* Beaudru Manuel's [ModernJS Cheatsheet](https://github.com/mbeaudru/modern-js-cheatsheet)
* Azat Mardan's [JavaScript and Node.js Cheatsheet](https://github.com/azat-co/cheatsheets)
* Sindre Sorhus's [Awesome List](https://github.com/sindresorhus/awesome)
* Google's [Web Fundamentals](https://github.com/google/WebFundamentals)
* Andre Staltz's [Reactive Programming Intro](https://gist.github.com/staltz/868e7e9bc2a7b8c1f754)

There are also articles, websites, and guides dedicated to best practices:

* [React Project Structuring Guide and Naming Conventions](https://hackernoon.com/structuring-projects-and-naming-components-in-react-1261b6e18d76)
* How to [write testable code](http://misko.hevery.com/attachments/Guide-Writing%20Testable%20Code.pdf) - [web version](http://misko.hevery.com/code-reviewers-guide/)
* [react.express](http://www.react.express/) - an all-in-one guide to modern React application development.


# Acquire The Right Mental Framework for The Industry

While having a diversity of thought in a company is valuable in spurring an overall improvement in creativity and adaptability of the company, having people who don't speak the same language and are not on the same page working together impedes productivity in the workplace. Thus, acquiring the mental framework and lexicon for the industry is essential for ensuring a "culture fit".

These are some resources for acquiring the perspective and learning the thought processes that I find extremely useful:

* [High Scalability Articles](http://highscalability.com/all-time-favorites/) to read for fun that teaches you how to think about difficult problems like the tradeoff between time and space, automation vs. "roll your own", and optimization.
* [Algorithms to Live By](https://www.amazon.com/Algorithms-Live-Computer-Science-Decisions/dp/1627790365) The Computer Science of Human Decisions by Brian Christian and Tom Griffiths - Peter Norvig, the director of Research at Google, highly praised this book at [Talks at Google](https://www.youtube.com/watch?v=OwKj-wgXteo) for its value in teaching you about how to apply computational, mathematical, and statistical thinking in problem solving.
* [Coders At Work](https://www.amazon.com/Coders-Work-Reflections-Craft-Programming/dp/1430219483) by Peter Seibel
* [97 Things Every Programmer Should Know](https://www.amazon.com/Things-Every-Programmer-Should-Know/dp/0596809484/ref=sr_1_1?s=books&ie=UTF8&qid=1524273996&sr=1-1&keywords=97+things+every+programmer+should+know) - Collective Wisdom from the Experts.

I like to read these articles and books on my phone while riding the subway, exercising on the elliptical, or waiting in line for coffee.

# Job Hunt

I don't have a lot to say about how many resumes you should send out or how to meet people at networking events to connect you with people who will give you an interview.

I never sent out a single resume or applied to any job post. **I let the recruiters come to me.**

In my experience, if you focus on building your skills and marketing yourself on LinkedIn and your personal website/blog, and establishing an online presence through open source contributions and writing for programming publications on Medium, recruiter will come to you.

If you don't put your work out there, no one will know what you are capable of. There are professional recruiters whose job is to look for qualified candidates for tech companies. Over the past few years, I've been putting more and more of my work on the internet and keep updating my LinkedIn and GitHub. I start seeing a rising trend of more recruiters coming to me about job opportunities from more well known companies. I had recruiters text me for a call that same day at 8PM for a software development job at Goldman Sachs. I had recruiters from LinkedIn and Facebook calling me to schedule interviews. I had a well funded startup founder asking me to join as an early employee to help build the React Native app that's the core of their product. I had a CEO who sold his previous company for $600 million ask me to have coffee to talk about opportunities at his new startup.

None of this would happen if I hadn't taken the time and effort steadily building up my skills and my body of work which substantiates my knowledge and accomplishments listed on my resume. Here are exactly what I have put out did to get to this point:

* Started building a web app called LooseLeaf. Hosting any prototype or work-in-progress versions of the website on [looseleafapp.com](http://looseleafapp.com/) and [github repos](https://github.com/xiaoyunyang/looseleaf-node).
* Work on interesting side projects like building a [travel app in React Native](https://github.com/xiaoyunyang/react-native-travel-app).
* Continue to update my [LinkedIn profile](https://www.linkedin.com/in/xiaoyun-yang/) and [my resume](https://drive.google.com/file/d/0B_uByl2mOTJIVTM3ZWRYRVpIcWs/view). I'm on version 13 of my resume now since 2015.
* Publishing programming articles [via DailyJS](https://medium.com/dailyjs/some-examples-to-help-understand-javascripts-closure-372e42fff94d) and [via HackerNoon](https://hackernoon.com/how-to-refactor-unwieldy-untestable-code-4a73d75cb80a).
* Creating my personal website. Using Github for free hosting: [http://xiaoyunyang.github.io/](http://xiaoyunyang.github.io/). Publishing blog articles on the personal website to build my brand and let the world know who I am and what I'm capable of.
* Contributing to open source projects such as creating learning repositories [for scala](https://github.com/xiaoyunyang/coursera-scala-specializatio) and [web development](https://github.com/xiaoyunyang/web-dev-cheatsheets).


# A Parting Thought

There's certainly a lot of jobs being created in this booming industry and needing people with the right skills to work there. The number of coding bootcamps have [grown 10x since the first bootcamps launched in 2012](https://www.coursereport.com/reports/2017-coding-bootcamp-market-size-research) and are turning people in their late 20s who have never coded in their lives into professional developers through their 14-week programs. This is both scary and amazing. The profound realization is that there's a desperate need for developers with the right skills, experience, and intelligence to be a high contributor in an industry that is at the forefront of change demands people with the ability and passion for solving challenging problems, constantly learning new things, and adapting to changes.
