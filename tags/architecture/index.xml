<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Architecture on Xiaoyun Yang</title>
    <link>https://xiaoyunyang.github.io/tags/architecture/</link>
    <description>Recent content in Architecture on Xiaoyun Yang</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>xiaoyun@looseleafapp.com (Xiaoyun Yang)</managingEditor>
    <webMaster>xiaoyun@looseleafapp.com (Xiaoyun Yang)</webMaster>
    <lastBuildDate>Mon, 15 Feb 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://xiaoyunyang.github.io/tags/architecture/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Modeling UI State Using A Finite State Machine</title>
      <link>https://xiaoyunyang.github.io/post/modeling-ui-state-using-a-finite-state-machine/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      <author>xiaoyun@looseleafapp.com (Xiaoyun Yang)</author>
      <guid>https://xiaoyunyang.github.io/post/modeling-ui-state-using-a-finite-state-machine/</guid>
      <description>&lt;p&gt;A finite state machine (FSM) is an architectural design pattern that allows us to model a large system as a collection of loosely coupled components. Each component in the system changes its behavior when the internal state changes. This pattern allows us to write flexible, reusable, and testable code. In this article, we will explore the use of FSM in building complex React components.&lt;/p&gt;
&lt;p&gt;The primary use of FSM has been in &lt;a href=&#34;https://www.embedded.com/programming-embedded-systems-the-easy-way-with-state-machines/&#34;&gt;programming embedded systems&lt;/a&gt; but in recent years, there has been an emergence of FSM in other applications like &lt;a href=&#34;https://www.smashingmagazine.com/2018/01/rise-state-machines/&#34;&gt;managing states in the browser&lt;/a&gt;, &lt;a href=&#34;https://mind-simulation.com/en/blog/tech/using-finite-state-machines-to-model-behavior.html&#34;&gt;modeling behavior&lt;/a&gt;, and &lt;a href=&#34;https://www.hamidadelyar.com/blog/finite-state-machine-chatbot/&#34;&gt;building chatbots&lt;/a&gt;. The goal of this post is not to evangelize FSM as a better state management solution than its alternatives like &lt;a href=&#34;http://redux.js.org/&#34;&gt;Redux&lt;/a&gt; but rather, to introduce a pattern for simplifying the architecture of a system and write robust code that is understandable, extendable, and &lt;a href=&#34;https://programmingisterrible.com/post/139222674273/how-to-write-disposable-code-in-large-systems&#34;&gt;delete-able&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
